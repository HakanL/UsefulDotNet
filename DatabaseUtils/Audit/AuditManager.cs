using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.EntityFrameworkCore;

namespace Haukcode.DatabaseUtils
{
    public class AuditManager<TAuditDataModel> where TAuditDataModel : class
    {
        private readonly Dictionary<string, Func<string, bool>> auditExclusion;
        private readonly Func<IAuditEntry, TAuditDataModel> createAuditDataModelInstanceFactory;

        public AuditManager(Func<IAuditEntry, TAuditDataModel> createAuditDataModelInstanceFactory)
        {
            this.auditExclusion = new Dictionary<string, Func<string, bool>>();
            this.createAuditDataModelInstanceFactory = createAuditDataModelInstanceFactory ?? throw new ArgumentNullException();
        }

        public void AddAuditExclusion(string tableName, Func<string, bool> propertyChecker = null)
        {
            if (string.IsNullOrEmpty(tableName))
                throw new ArgumentNullException();

            this.auditExclusion.Add(tableName, propertyChecker);
        }

        public AuditResult<TAuditDataModel> OnBeforeSaveChanges(DbContext dbContext, DbSet<TAuditDataModel> auditTable)
        {
            dbContext.ChangeTracker.DetectChanges();
            var auditEntries = new List<AuditEntry>();
            foreach (var entry in dbContext.ChangeTracker.Entries())
            {
                if (entry.Entity is TAuditDataModel || entry.State == EntityState.Detached || entry.State == EntityState.Unchanged)
                    continue;

                var auditEntry = new AuditEntry(entry)
                {
                    TableName = entry.Metadata.DisplayName()
                };

                if (this.auditExclusion.TryGetValue(auditEntry.TableName, out var propertyChecker) && propertyChecker == null)
                    // Skip the table
                    continue;

                bool dirty = false;
                foreach (var property in entry.Properties)
                {
                    string propertyName = property.Metadata.Name;

                    bool skipProperty = false;
                    if (propertyChecker != null && !propertyChecker(propertyName))
                        skipProperty = true;

                    if (property.IsTemporary)
                    {
                        // Value will be generated by the database, get the value after saving
                        auditEntry.TemporaryProperties.Add(property);

                        if (!property.Metadata.IsPrimaryKey() && !skipProperty)
                            dirty = true;
                        continue;
                    }

                    if (property.Metadata.IsPrimaryKey())
                    {
                        auditEntry.KeyValues[propertyName] = property.CurrentValue;
                        continue;
                    }

                    if (!skipProperty)
                    {
                        switch (entry.State)
                        {
                            case EntityState.Added:
                                auditEntry.NewValues[propertyName] = property.CurrentValue;
                                dirty = true;
                                break;

                            case EntityState.Deleted:
                                auditEntry.OldValues[propertyName] = property.OriginalValue;
                                dirty = true;
                                break;

                            case EntityState.Modified:
                                if (property.IsModified)
                                {
                                    auditEntry.OldValues[propertyName] = property.OriginalValue;
                                    auditEntry.NewValues[propertyName] = property.CurrentValue;
                                    dirty = true;
                                }
                                break;
                        }
                    }
                }

                if (dirty && auditEntry.OldValues.Any())
                    // Only audit changes, not inserts
                    auditEntries.Add(auditEntry);
            }

            // Save audit entities that have all the modifications
            foreach (var auditEntry in auditEntries.Where(_ => !_.HasTemporaryProperties))
            {
                var auditDataModel = this.createAuditDataModelInstanceFactory(auditEntry);
                if (auditDataModel != null)
                    auditTable.Add(auditDataModel);
            }

            // Keep a list of entries where the value of some properties are unknown at this step
            return new AuditResult<TAuditDataModel>(
                auditTable: auditTable,
                auditEntries: auditEntries.Where(_ => _.HasTemporaryProperties).ToList());
        }

        public void OnAfterSaveChanges(AuditResult<TAuditDataModel> auditResult)
        {
            if (auditResult == null)
                throw new ArgumentNullException();

            if (auditResult.AuditEntries == null || auditResult.AuditEntries.Count == 0)
                return;

            foreach (var auditEntry in auditResult.AuditEntries)
            {
                // Get the final value of the temporary properties
                foreach (var prop in auditEntry.TemporaryProperties)
                {
                    if (prop.Metadata.IsPrimaryKey())
                    {
                        auditEntry.KeyValues[prop.Metadata.Name] = prop.CurrentValue;
                    }
                    else
                    {
                        auditEntry.NewValues[prop.Metadata.Name] = prop.CurrentValue;
                    }
                }

                // Save the Audit entry
                var auditDataModel = this.createAuditDataModelInstanceFactory(auditEntry);
                if (auditDataModel != null)
                    auditResult.AuditTable.Add(auditDataModel);
            }
        }

        public async Task<int> SaveChangesAsync(
            DbContext dbContext,
            Func<bool, CancellationToken, Task<int>> saveChangesAsync,
            DbSet<TAuditDataModel> auditTable,
            bool acceptAllChangesOnSuccess,
            CancellationToken cancellationToken = default)
        {
            var auditResult = OnBeforeSaveChanges(dbContext, auditTable);

            int result = await saveChangesAsync(acceptAllChangesOnSuccess, cancellationToken);

            OnAfterSaveChanges(auditResult);

            await saveChangesAsync(acceptAllChangesOnSuccess, cancellationToken);

            return result;
        }

        public int SaveChanges(
            DbContext dbContext,
            Func<bool, int> saveChanges,
            DbSet<TAuditDataModel> auditTable,
            bool acceptAllChangesOnSuccess)
        {
            var auditResult = OnBeforeSaveChanges(dbContext, auditTable);

            int result = saveChanges(acceptAllChangesOnSuccess);

            OnAfterSaveChanges(auditResult);

            saveChanges(acceptAllChangesOnSuccess);

            return result;
        }
    }
}
